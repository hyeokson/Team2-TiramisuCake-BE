<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JwtAuthenticationFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">backend</a> &gt; <a href="index.source.html" class="el_package">com.softeer.backend.global.filter</a> &gt; <span class="el_source">JwtAuthenticationFilter.java</span></div><h1>JwtAuthenticationFilter.java</h1><pre class="source lang-java linenums">package com.softeer.backend.global.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.softeer.backend.global.common.code.status.ErrorStatus;
import com.softeer.backend.global.common.dto.JwtClaimsDto;
import com.softeer.backend.global.common.exception.JwtAuthenticationException;
import com.softeer.backend.global.common.response.ResponseDto;
import com.softeer.backend.global.config.properties.JwtProperties;
import com.softeer.backend.global.util.JwtUtil;
import com.softeer.backend.global.util.StringRedisUtil;
import com.softeer.backend.global.common.dto.JwtTokenResponseDto;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.util.PatternMatchUtils;
import org.springframework.web.cors.CorsUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.io.OutputStream;
import java.time.LocalDateTime;

/**
 * Jwt 인증을 처리하는 필터 클래스
 */
<span class="nc" id="L31">@Slf4j</span>
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    // 인증검사를 하지 않는 url 설정
    private final String[] whiteListUrls = {
            &quot;/swagger-ui/**&quot;, &quot;/swagger&quot;, &quot;/v3/**&quot;, &quot;/error/**&quot;,
            &quot;/verification/send&quot;, &quot;/verification/confirm&quot;, &quot;/verification/send/test&quot;,
            &quot;/login&quot;,
            &quot;/main/event/static&quot;, &quot;/main/event/info&quot;, &quot;/main/car&quot;,
            &quot;/admin/login&quot;, &quot;/admin/signup&quot;,
            &quot;/share/**&quot;
    };

    // Access Token이 header에 있으면 인증하고 없으면 인증하지 않는 url 설정
    private final String[] optionalAuthUrls = {
            &quot;/comment&quot;,
            &quot;/share-shorten-url&quot;
    };

    private final JwtUtil jwtUtil;
    private final StringRedisUtil stringRedisUtil;
    private final JwtProperties jwtProperties;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        // preflight 요청 또는 whitelist에 있는 요청은 인증 검사 x
<span class="nc bnc" id="L59" title="All 4 branches missed.">        if (CorsUtils.isPreFlightRequest(request) || isUriInWhiteList(request.getRequestURI())) {</span>
<span class="nc" id="L60">            filterChain.doFilter(request, response);</span>
<span class="nc" id="L61">            return;</span>
        }

        // optionalAuthUrls에 등록된 url 중, access token이 header에 없으면 인증 x
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (isUriInOptionalAuthList(request.getRequestURI()) &amp;&amp;</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">                jwtUtil.extractAccessToken(request).isEmpty()) {</span>

<span class="nc" id="L68">            filterChain.doFilter(request, response);</span>
<span class="nc" id="L69">            return;</span>
        }


        // Case 01) Access Token 재발급인 경우(Authorization Header Access Token 유효성 x)
<span class="nc bnc" id="L74" title="All 2 branches missed.">        if (request.getRequestURI().contains(&quot;/reissue&quot;)) {</span>
<span class="nc" id="L75">            String accessToken = jwtUtil.extractAccessToken(request).orElseThrow(() -&gt; {</span>
<span class="nc" id="L76">                log.error(&quot;Access Token is missing in the Authorization header during the '/reissue' process.&quot;);</span>
<span class="nc" id="L77">                return new JwtAuthenticationException(ErrorStatus._REISSUE_ERROR);</span>
            });
<span class="nc" id="L79">            String refreshToken = jwtUtil.extractRefreshToken(request).orElseThrow(() -&gt; {</span>
<span class="nc" id="L80">                log.error(&quot;Refresh Token is missing in the Authorization header during the '/reissue' process.&quot;);</span>
<span class="nc" id="L81">                return new JwtAuthenticationException(ErrorStatus._REISSUE_ERROR);</span>
            });

<span class="nc" id="L84">            this.reissueAccessTokenAndRefreshToken(response, accessToken, refreshToken);</span>
<span class="nc" id="L85">        }</span>
        // Case 02) 일반 API 요청인 경우
        else {
<span class="nc" id="L88">            checkAccessToken(request);</span>
<span class="nc" id="L89">            log.info(&quot;jwtAuthentication filter is finished&quot;);</span>

            // Authentication Exception 없이 정상 인증처리 된 경우
            // 기존 필터 체인 호출
<span class="nc" id="L93">            filterChain.doFilter(request, response);</span>
        }
<span class="nc" id="L95">    }</span>

    private boolean isUriInWhiteList(String url) {
<span class="nc" id="L98">        return PatternMatchUtils.simpleMatch(whiteListUrls, url);</span>
    }

    private boolean isUriInOptionalAuthList(String url) {
<span class="nc" id="L102">        return PatternMatchUtils.simpleMatch(optionalAuthUrls, url);</span>
    }

    private void reissueAccessTokenAndRefreshToken(HttpServletResponse response,
                                                   String accessToken, String refreshToken) throws IOException {
        /**
         * 1. refresh token 유효성 검증
         * 2. access token 유효성 검증(유효하지 않아야 함)
         * 3. redis refresh 와 일치 여부 확인
         */
<span class="nc" id="L112">        checkAllConditions(accessToken, refreshToken);</span>
<span class="nc" id="L113">        String newAccessToken = jwtUtil.createAccessToken(jwtUtil.getJwtClaimsFromRefreshToken(refreshToken));</span>
<span class="nc" id="L114">        String newRefreshToken = reIssueRefreshToken(jwtUtil.getJwtClaimsFromRefreshToken(refreshToken));</span>
<span class="nc" id="L115">        makeAndSendAccessTokenAndRefreshToken(response, newAccessToken, newRefreshToken);</span>
<span class="nc" id="L116">    }</span>

    // Access Token + Refresh Token 재발급 메소드
    private void checkAllConditions(String accessToken, String refreshToken) {
        /**
         * 1. access Token 유효하지 않은지 확인
         * 2. refresh Token 유효한지 확인
         * 3. refresh Token 일치하는지 확인
         **/
<span class="nc" id="L125">        validateAccessToken(accessToken);</span>
<span class="nc" id="L126">        validateRefreshToken(refreshToken);</span>
<span class="nc" id="L127">        isRefreshTokenMatch(refreshToken);</span>
<span class="nc" id="L128">    }</span>

    private void validateAccessToken(String accessToken) {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (jwtUtil.validateToken(accessToken)) {</span>
<span class="nc" id="L132">            log.error(&quot;JWT Access Token is valid during the '/reissue' process.&quot;);</span>
<span class="nc" id="L133">            throw new JwtAuthenticationException(ErrorStatus._REISSUE_ERROR);</span>
        }
<span class="nc" id="L135">    }</span>

    private void validateRefreshToken(String refreshToken) {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (!this.jwtUtil.validateToken(refreshToken)) {</span>
<span class="nc" id="L139">            log.error(&quot;JWT Refresh Token is invalid during the '/reissue' process.&quot;);</span>
<span class="nc" id="L140">            throw new JwtAuthenticationException(ErrorStatus._REISSUE_ERROR);</span>
        }
<span class="nc" id="L142">    }</span>

    private void isRefreshTokenMatch(String refreshToken) {
<span class="nc" id="L145">        JwtClaimsDto jwtClaimsDto = jwtUtil.getJwtClaimsFromRefreshToken(refreshToken);</span>

<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (stringRedisUtil.getData(stringRedisUtil.getRedisKeyForJwt(jwtClaimsDto)) == null ||</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                !refreshToken.equals(stringRedisUtil.getData(stringRedisUtil.getRedisKeyForJwt(jwtClaimsDto)))) {</span>

<span class="nc" id="L150">            log.error(&quot;WT Refresh Token is either missing in Redis or does not match the token in Redis.&quot;);</span>
<span class="nc" id="L151">            throw new JwtAuthenticationException(ErrorStatus._REISSUE_ERROR);</span>
        }
<span class="nc" id="L153">    }</span>

    /**
     * refresh token 재발급 하는 메소드
     * 1. 새로운 Refresh Token 발급
     * 2. 해당 Key 에 해당하는 Redis Value 업데이트
     **/
    private String reIssueRefreshToken(JwtClaimsDto jwtClaimsDto) {
        // 기존 refresh token 삭제
<span class="nc" id="L162">        stringRedisUtil.deleteData(stringRedisUtil.getRedisKeyForJwt(jwtClaimsDto));</span>
<span class="nc" id="L163">        String reIssuedRefreshToken = jwtUtil.createRefreshToken(jwtClaimsDto);</span>
        // refresh token 저장
<span class="nc" id="L165">        stringRedisUtil.setDataExpire(stringRedisUtil.getRedisKeyForJwt(jwtClaimsDto), reIssuedRefreshToken, jwtProperties.getRefreshExpiration());</span>
<span class="nc" id="L166">        return reIssuedRefreshToken;</span>
    }

    /**
     * 재발급한 refresh &amp; access token 응답으로 보내는 메소드
     * 1. 상태 코드 설정
     * 2. 응답 헤더에 설정 (jwtProperties 에서 정보 가져옴)
     **/
    private void makeAndSendAccessTokenAndRefreshToken(HttpServletResponse response,
                                                       String accessToken,
                                                       String refreshToken) throws IOException {
<span class="nc" id="L177">        LocalDateTime expireTime = LocalDateTime.now().plusSeconds(this.jwtProperties.getAccessExpiration() / 1000);</span>
        // refresh token, access token 을 응답 본문에 넣어 응답
<span class="nc" id="L179">        JwtTokenResponseDto jwtTokenResponseDto = JwtTokenResponseDto.builder()</span>
<span class="nc" id="L180">                .accessToken(accessToken)</span>
<span class="nc" id="L181">                .refreshToken(refreshToken)</span>
<span class="nc" id="L182">                .expiredTime(expireTime)</span>
<span class="nc" id="L183">                .build();</span>
<span class="nc" id="L184">        makeResultResponse(response, jwtTokenResponseDto);</span>
<span class="nc" id="L185">    }</span>

    private void makeResultResponse(HttpServletResponse response,
                                    JwtTokenResponseDto jwtTokenResponseDto) throws IOException {
<span class="nc" id="L189">        response.setStatus(HttpStatus.OK.value());</span>
<span class="nc" id="L190">        response.setContentType(&quot;application/json&quot;);</span>
<span class="nc" id="L191">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span>

<span class="nc" id="L193">        try (OutputStream os = response.getOutputStream()) {</span>
<span class="nc" id="L194">            ObjectMapper objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());</span>
<span class="nc" id="L195">            ResponseDto&lt;JwtTokenResponseDto&gt; responseDto = ResponseDto.onSuccess(jwtTokenResponseDto);</span>
<span class="nc" id="L196">            objectMapper.writeValue(os, responseDto);</span>
<span class="nc" id="L197">            os.flush();</span>
        }
<span class="nc" id="L199">    }</span>

    private void checkAccessToken(HttpServletRequest request) {

<span class="nc" id="L203">        String accessToken = jwtUtil.extractAccessToken(request)</span>
<span class="nc" id="L204">                .orElseThrow(() -&gt; {</span>
<span class="nc" id="L205">                    log.error(&quot;Access Token is missing in the Authorization header.&quot;);</span>
<span class="nc" id="L206">                    return new JwtAuthenticationException(ErrorStatus._UNAUTHORIZED);</span>
                });

<span class="nc" id="L209">        JwtClaimsDto jwtClaimsDto = jwtUtil.getJwtClaimsFromAccessToken(accessToken);</span>

<span class="nc" id="L211">        request.setAttribute(&quot;jwtClaims&quot;, jwtClaimsDto);</span>
<span class="nc" id="L212">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>